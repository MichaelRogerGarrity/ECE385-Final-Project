/************************************************************************
Avalon-MM Interface VGA Text mode display

Register Map:
0x000-0x0257 : VRAM, 80x30 (2400 byte, 600 word) raster order (first column then row)
0x258        : control register

VRAM Format:
X->
[ 31  30-24][ 23  22-16][ 15  14-8 ][ 7    6-0 ]
[IV3][CODE3][IV2][CODE2][IV1][CODE1][IV0][CODE0]

IVn = Draw inverse glyph
CODEn = Glyph code from IBM codepage 437

Control Register Format:
[[31-25][24-21][20-17][16-13][ 12-9][ 8-5 ][ 4-1 ][   0    ] 
[[RSVD ][FGD_R][FGD_G][FGD_B][BKG_R][BKG_G][BKG_B][RESERVED]

VSYNC signal = bit which flips on every Vsync (time for new frame), used to synchronize software
BKG_R/G/B = Background color, flipped with foreground when IVn bit is set
FGD_R/G/B = Foreground color, flipped with background when Inv bit is set

************************************************************************/
`define NUM_REGS 601 //80*30 characters / 4 characters per register
`define CTRL_REG 600 //index of control register

module vga_text_avl_interface (
	// Avalon Clock Input, note this clock is also used for VGA, so this must be 50Mhz
	// We can put a clock divider here in the future to make this IP more generalizable
	input logic CLK,
	
	// Avalon Reset Input
	input logic RESET,
	
	// Avalon-MM Slave Signals
	input  logic AVL_READ,					// Avalon-MM Read
	input  logic AVL_WRITE,					// Avalon-MM Write
	input  logic AVL_CS,					// Avalon-MM Chip Select
	input  logic [3:0] AVL_BYTE_EN,			// Avalon-MM Byte Enable
	input  logic [9:0] AVL_ADDR,			// Avalon-MM Address
	input  logic [31:0] AVL_WRITEDATA,		// Avalon-MM Write Data
	output logic [31:0] AVL_READDATA,		// Avalon-MM Read Data
	
	// Exported Conduit (mapped to VGA port - make sure you export in Platform Designer)
	output logic [3:0]  red, green, blue,	// VGA color channels (mapped to output pins in top-level)
	output logic hs, vs						// VGA HS/VS
);

logic [31:0] LOCAL_REG       [`NUM_REGS]; // Registers
//put other local variables here
logic blank,sync,VGA_VS,VGA_HS,VGA_clk;
logic [7:0] sprite_data;
logic [10:0] sprite_addr;
logic [9:0] DrawX,DrawY;

//Declare submodules..e.g. VGA controller, ROMS, etc
vga_controller vga_mod( .Clk(MAX10_CLK1_50),.Reset(RESET),.hs(VGA_HS),.vs(VGA_VS),.pixel_clk(VGA_clk), .blank(blank),.sync(sync),  
								.DrawX(DrawX),.DrawY(DrawY) 
);
//to start mult vram addr *16 // just shift left 4 to get 11 bit addr
font_rom font_rom_mod(.addr(sprite_addr),.data(sprite_data)

);

/*
color_mapper color_mod( .BallX(ballxsig),.BallY(ballysig), .DrawX(drawxsig), .DrawY(drawysig),.Ball_size(ballsizesig),
                       .Red(Red),.Green(Green), .Blue(Blue) 

);	


   
// Read and write from AVL interface to register block, note that READ waitstate = 1, so this should be in always_ff
*/
// control reg CTRL_REG
//RESET
always_ff @(posedge CLK) begin

//RESEt set all regs to 0
if(RESET)
	begin
	for(int i = 0; i<601;i++)
	LOCAL_REG[i] <= 0;
	end
	
if(AVL_WRITE && AVL_CS)
	begin
	if(AVL_BYTE_EN == 4'b1111) //full 32
		begin
		LOCAL_REG[AVL_ADDR] <= AVL_WRITEDATA;
		end
		
	else if (AVL_BYTE_EN == 4'b1100)
		begin //upper 2 bytes
		LOCAL_REG[AVL_ADDR][31:16] <= AVL_WRITEDATA[31:16];
		end
		
	else if (AVL_BYTE_EN == 4'b0011)
		begin //2 lower bytes
	  LOCAL_REG[AVL_ADDR][15:0] <= AVL_WRITEDATA[15:0];
		end
		
	else if (AVL_BYTE_EN == 4'b1000)
		begin 
		LOCAL_REG[AVL_ADDR][31:24] <= AVL_WRITEDATA[31:24];
		end
		
	else if (AVL_BYTE_EN == 4'b0100)
		begin 
		LOCAL_REG[AVL_ADDR][23:16]<= AVL_WRITEDATA[23:16];
		end
		
	else if (AVL_BYTE_EN == 4'b0010)
		begin 
		LOCAL_REG[AVL_ADDR][15:8] <= AVL_WRITEDATA[15:8];
		end
		
	else if (AVL_BYTE_EN == 4'b0001)
		begin 
		LOCAL_REG[AVL_ADDR][7:0] <= AVL_WRITEDATA[7:0];
		end
	end
	
		//read ready wihitin 1 wait state 1 clock cycle 
		if(AVL_READ && AVL_CS)
		begin
		AVL_READDATA <= LOCAL_REG[AVL_ADDR];
		end 
end


//calc curr addr of font rom
// rownum =sprite_addr*16 + drawY%16
//colnum = sprite_data[drawX%8]

logic [12:0] ac; 
logic [8:0] av;
logic [31:0] vdata;
logic [7:0] chard;
logic sprite_on;
logic sprite_inv;
logic [11:0] rgb_back, rgb_fore;

//handle drawing (may either be combinational or sequential - or both).

//XOR to get for or back

always_comb
begin
ac = DrawX[9:3] + DrawY[9:4]*80;
av = ac[11:2];
vdata = LOCAL_REG[av];
if(ac[1:0] == 2'b00)
	begin
	chard = vdata[7:0]; 
	end
	
else if(ac[1:0] == 2'b01)
	begin
	chard = vdata[15:8]; 
	end
	
else if(ac[1:0] == 2'b10)
	begin
	chard = vdata[23:16]; 
	end
	
else if (ac[1:0] == 2'b11)
	begin
	chard = vdata[31:24]; 
	end
	
sprite_addr = chard[6:0]*16 + DrawY[3:0];

sprite_on = sprite_data[7-DrawX[2:0]];
sprite_inv = chard[8];

rgb_back = LOCAL_REG[600][12:1];
rgb_fore = LOCAL_REG[600][24:13];
end




//write to rgb pixel clk
always_ff @(posedge VGA_clk) 
begin
//set rgb
	if(sprite_on ^ sprite_inv)
	begin
	//fore
		red <= rgb_fore[24:21];
		green <= rgb_fore[20:17];
		blue <= rgb_fore[16:13];
	end
	
	else
	begin
	//back
		red <= rgb_back[12:9];
		green <= rgb_back[8:5];
		blue <= rgb_back[4:1];
	end


end

// calc sprite_addr how to ignore input bit, mem logic, draw sprite , main.c use

/*
logic shape_on;
logic[10:0] shape_x =300;
logic[10:0] shape_y = 300;
logic[10:0] shape_size_x = 8;
logic[10:0] shape_size_y = 16;

logic shape2_on;
logic[10:0] shape2_x =100;
logic[10:0] shape2_y = 100;
logic[10:0] shape2_size_x = 8;
logic[10:0] shape2_size_y = 16;

always_comb
begin:Ball_on_proc
	if(DrawX >= shape_x && DrawX < shape_x + shape_size_x &&
	DrawY >= shape_y && DrawY < shape_y + shape_size_y)
	begin
		shape_on = 1'b1;
		shape2_on = 1'b0;
		sprite_addr= (DrawY-shape_y + 16*'h48);
	end
	else if(DrawX >= shape2_x && DrawX < shape2_x + shape2_size_x &&
				DrawY >= shape2_y && DrawY < shape2_y + shape2_size_y)
				
	begin
		shape_on = 1'b0;
		shape2_on = 1'b1;
		sprite_addr = (DrawY-shape2_y + 16*'h49);
	end
	else
	begin
		shape_on = 1'b0;
		shape2_on = 1'b0;
		sprite_addr = 10'b0;
		
	end
end	

always_comb
begin:RBG_Display
	if((shape_on == 1'b1) && sprite_data[DrawX - shape_x] == 1'b1)
	begin
		red = 8'h00;
		green = 8'hff;
		blue = 8'hff;
	end
	
	else if ((shape2_on == 1'b1) && sprite_data[DrawX - shape2_x] == 1'b1)
	begin 
		red = 8'hff;
		green = 8'hff;
		blue = 8'h00;
	end
	
	else
	begin
		red = 8'h4f - DrawX[9:3];
		green = 8'h00;
		blue = 8'h44;
	
	end

end

*/

endmodule
